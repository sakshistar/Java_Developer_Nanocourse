WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.720
Some of you, might have already worked with a relational database.

00:00:03.720 --> 00:00:09.255
Relational databases have been the de facto standard for persistence for decades.

00:00:09.255 --> 00:00:13.140
Up until the advent of NoSQL databases a few years ago,

00:00:13.140 --> 00:00:17.085
the word database was synonymous with the relational database.

00:00:17.085 --> 00:00:20.775
Let's define what a relational database is.

00:00:20.774 --> 00:00:24.089
A relational database is a collection of data items

00:00:24.089 --> 00:00:28.964
organized as a set of tables with columns and rows.

00:00:28.964 --> 00:00:32.594
Each row in a table can have a unique identifier,

00:00:32.594 --> 00:00:34.560
called a primary key.

00:00:34.560 --> 00:00:40.980
Rows among multiple tables can be made related using foreign keys.

00:00:40.979 --> 00:00:44.504
The structure of a table is predefined,

00:00:44.505 --> 00:00:48.094
meaning a table is created with a set of columns.

00:00:48.094 --> 00:00:52.265
Rows for that table can only contain those predefined set of columns.

00:00:52.265 --> 00:00:55.969
This definition is called a schema.

00:00:55.969 --> 00:01:00.814
Some applications might require a more flexible data model.

00:01:00.814 --> 00:01:04.399
In lesson three, we'll explore how non-relational,

00:01:04.400 --> 00:01:07.980
NoSQL databases provide an alternate data model.

00:01:07.980 --> 00:01:13.520
Another important feature of a relational database is its support for transactions.

00:01:13.519 --> 00:01:20.254
Transactions are a very powerful feature and can come in handy during various scenarios.

00:01:20.254 --> 00:01:23.209
A transaction is a set of operations

00:01:23.209 --> 00:01:27.243
executed sequentially and independent of other operations,

00:01:27.243 --> 00:01:30.334
backed by an all or nothing guarantee.

00:01:30.334 --> 00:01:34.444
This last term, all or nothing is called atomicity.

00:01:34.444 --> 00:01:37.339
Let's illustrate transactions with an example.

00:01:37.340 --> 00:01:38.900
In a banking application,

00:01:38.900 --> 00:01:43.130
a common use case is to transfer money from one account to another.

00:01:43.129 --> 00:01:45.739
Let's say, money needs to be transferred from

00:01:45.739 --> 00:01:49.489
the salary checking to this college savings account.

00:01:49.489 --> 00:01:54.149
This transfer involves two operations.

00:01:54.670 --> 00:01:58.579
Debit from the salary checking account here,

00:01:58.579 --> 00:02:02.135
and credit to the college savings account here.

00:02:02.135 --> 00:02:06.990
It would be catastrophic if the debit succeeds,

00:02:06.989 --> 00:02:09.150
but the credit fails.

00:02:09.150 --> 00:02:12.289
If this application uses a relational database,

00:02:12.289 --> 00:02:18.079
a transaction guarantees that both of these operations happen are none of it.

00:02:18.080 --> 00:02:20.360
If one of the operations fail,

00:02:20.360 --> 00:02:25.325
then the database is restored to a state before these operations have been attempted.

00:02:25.324 --> 00:02:29.089
As you can see, there are certain use cases where

00:02:29.090 --> 00:02:33.840
guarantee is provided by a transaction are absolutely needed.

