WEBVTT
Kind: captions
Language: ar

00:00:00.000 --> 00:00:04.872
لكن حتى لو قررنا إيقاف المنبّه
بعد مئة رنة مثلاً

00:00:04.972 --> 00:00:07.174
بغض النظر عما إذا قام أحدهم بإيقافه أم لا،

00:00:07.274 --> 00:00:12.813
فسيظل علينا
نسخ ولصق كتلة "if" هذه مئة مرة.

00:00:12.913 --> 00:00:14.648
هذا مريع.

00:00:14.748 --> 00:00:16.884
لا بد من وجود حل. صحيح؟

00:00:16.984 --> 00:00:20.654
في الواقع لغة Java
لديها حل يُسمى التكرار الحلقي.

00:00:20.754 --> 00:00:22.389
لنتعرف على آلية عملها.

00:00:22.489 --> 00:00:27.828
في لغة Java، بدلاً من استخدام if،
يمكنك استخدام شيء يُدعى while،

00:00:27.928 --> 00:00:30.664
وهو شبيه جداً بجملة شرط "if"،

00:00:30.764 --> 00:00:33.734
باستثناء أنه بدلاً
من التحقق من الشرط مرة واحدة،

00:00:33.834 --> 00:00:38.372
تستمر جملة while
بالتحقق من الشرط وتطبيق الكتلة الواقعة هنا

00:00:38.472 --> 00:00:40.774
كلما تم استيفاء الشرط.

00:00:40.874 --> 00:00:43.010
إذن ما يحصل في كتلة الكود كهذه

00:00:43.110 --> 00:00:46.113
هو أن while ستتحقق مما إذا كانت
نتيجة تقييم المتغيّر "on" هي "true"،

00:00:46.213 --> 00:00:47.915
وإذا كانت كذلك،
عندئذ ستدخل إلى المستوى الأدنى،

00:00:48.015 --> 00:00:49.650
وتنفّذ كتلة الكود هذه بالكامل،

00:00:49.750 --> 00:00:52.286
ثم تعود إلى الأعلى لتتحقق مجدداً،

00:00:52.386 --> 00:00:54.388
وإذا كانت ما تزال صواباً "true"
عندئذ ستعود إلى المستوى الأدنى

00:00:54.488 --> 00:00:59.393
وتكرر هذا الجزء مراراً
حتى لا تعود نتيجة تقييم "on" هي "true"،

00:00:59.493 --> 00:01:02.462
وعندها ستتخطى
هذا الجزء وتتابع إلى الجملة التالية.

00:01:02.563 --> 00:01:05.199
وهذا هو سبب تسميتها بحلقات "while"
ومعناها "طالما".

00:01:05.299 --> 00:01:09.803
لأنها لا تنفك تدور
في حلقات مروراً بكتلة الكود هذه

00:01:09.903 --> 00:01:14.408
عدد ما يلزم من المرات
طالما بقي هذا الشرط متحققاً.

00:01:14.508 --> 00:01:18.612
وهذا يعني ببساطة
أن كتلة "while" الواحدة هذه

00:01:18.712 --> 00:01:23.350
يمكنها أن تحل محل
جميع كتل "if" المكررة تلك.

00:01:23.450 --> 00:01:28.722
لذا، بدلاً من الحاجة إلى التحقق من المتغير
"on" عدة مرات في عدة كتل "if"،

00:01:28.822 --> 00:01:31.191
يمكننا التحقق منه باستخدام حلقة while،

00:01:31.291 --> 00:01:37.464
والتي بدورها ستكرر تنفيذ هذه الكتلة مراراً
حتى لا تعود قيمة "on" هي "true".

00:01:37.564 --> 00:01:42.402
ولأننا نقوم بتحديث متغيّرنا هنا
باستخدام دالة checkAlarm،

00:01:42.503 --> 00:01:45.038
ستُرجع الدالة القيمة "false"
في نهاية المطاف

00:01:45.138 --> 00:01:48.976
عندما يوقف أحدهم المنبه
جاعلاً قيمة المتغيّر "on" هي "false".

00:01:49.076 --> 00:01:52.846
لذا ستتوقف حلقة "while" هذه
في مرحلة ما.

00:01:52.946 --> 00:01:57.851
دعنا نتتبع هذه الدالة باستخدام
حلقة "while" لنرى آلية عملها.

00:01:57.951 --> 00:02:00.220
تبدو دالتنا المُحدَثة بهذا الشكل.

00:02:00.320 --> 00:02:04.958
نبدأ بإنشاء المتغيّر المنطقي "on"
والتحقق من المنبه

00:02:05.058 --> 00:02:07.394
ثم نستعيض عن كتل "if" المكررة هذه،

00:02:07.494 --> 00:02:12.966
بحلقة "while" واحدة
تتحقق مما إذا كانت قيمة "on" هي "true".

00:02:13.066 --> 00:02:15.269
وإذا كانت كذلك، يبدأ المنبّه بالعمل

00:02:15.369 --> 00:02:19.540
ثم تقوم بتحديث المتغيّر "on" مرة أخرى
باستخدام دالة "checkAlarm".

00:02:19.640 --> 00:02:22.342
تذكروا أن دالة "checkAlarm"

00:02:22.442 --> 00:02:25.712
تُرجع قيمة منطقية
تكون إما "true" إذا كان المنبه يعمل

00:02:25.812 --> 00:02:27.781
وإما "false"
إذا ما تم إيقاف تشغيله المنبه.

00:02:27.881 --> 00:02:29.983
لنتتبع هذه الدالة ونرى آلية عملها.

00:02:30.083 --> 00:02:35.222
أول ما نقوم به هو استدعاء
دالة "checkAlarm" لنهيئة المتغيّر "on".

00:02:35.322 --> 00:02:37.357
ولأن الساعة هي السادسة،

00:02:37.457 --> 00:02:39.693
ستُرجع دالة "checkAlarm"
القيمة "true".

00:02:39.793 --> 00:02:42.629
ما يعني أنه ينبغي للمنبّه
أن يبدأ في العمل.

00:02:42.729 --> 00:02:45.232
لذا ستكون قيمة
المتغيّر "on" هي "true"،

00:02:45.332 --> 00:02:49.536
ما يعني أن نتيجة التحقق
من شرط "while" هنا ستكون "true"،

00:02:49.636 --> 00:02:52.739
أي أنها ستدخل المستوى الأدنى
وتبدأ بإصدار صوت المنبّه.

00:02:52.840 --> 00:02:57.044
إذن، هذا سيُفعّل صوت المنبّه.

00:02:57.144 --> 00:03:01.515
ثم نتحقق من المنبّه مرة أخرى
لتحديث المتغيّر "on".

00:03:01.615 --> 00:03:03.417
ولأن أحداً لم يضغط
على زر الغفوة "snooze" بعد،

00:03:03.517 --> 00:03:05.886
ستظل دالة "checkAlarm" تُرجع القيمة "true"،

00:03:05.986 --> 00:03:09.590
ما يجعل قيمة المتغيّر "on"
هي "true" أيضاً.

00:03:09.690 --> 00:03:11.525
بهذا نصل إلى نهاية الحلقة،

00:03:11.625 --> 00:03:15.162
لذا نعود إلى الأعلى مجدداً ونتحقق مما
إذا كانت القيمة تساوي "true" مرة أخرى.

00:03:15.262 --> 00:03:17.064
ولأن قيمة "on" هي "true"،

00:03:17.164 --> 00:03:20.934
فإننا ندخل المستوى الأدنى
وتستدعي دالة beep مجدداً،

00:03:21.034 --> 00:03:23.470
والتي بدورها تأمر الساعة
بإطلاق صوت المنبّه.

00:03:23.570 --> 00:03:26.874
ثم نتحقق من المنبّه مرة أخرى.

00:03:26.974 --> 00:03:30.811
والآن، تخيّلوا أن أحدهم
قام بالضغط على زر الغفوة.

00:03:30.911 --> 00:03:34.748
هذا يعني أنه عند استدعاء دالة "checkAlarm"
لنتحقق مما إذا كان المنبّه ما زال يعمل،

00:03:34.848 --> 00:03:36.984
فإنها تُرجع القيمة "false"

00:03:37.084 --> 00:03:41.221
وبالتالي تصبح قيمة "on" هي "false" أيضاً.

00:03:41.321 --> 00:03:43.357
وبهذا نصل إلى نهاية الحلقة،

00:03:43.457 --> 00:03:46.159
فنعود إلى أعلى لنقوم بالمقارنة مرة أخرى.

00:03:46.260 --> 00:03:49.663
ولأن أن شرط "while" لم يعد متحققاً،

00:03:49.763 --> 00:03:53.333
فإننا لا ندخل المستوى الأدنى،
وبالتالي لا ينطلق صوت المنبّه.

00:03:53.433 --> 00:03:55.102
فلا يعود هناك فعل يتم تنفيذه،

00:03:55.202 --> 00:03:58.138
وهذا معناه ببساطة
أن حلقة "while" قد انتهت،

00:03:58.238 --> 00:04:00.073
وأنها لن تتحقق أو تحاول مرة أخرى،

00:04:00.174 --> 00:04:05.179
وإنما ستواصل تشغيل بقية البرنامج،
ولأنه لا توجد بقية، يتوقف عمل الدالة.

00:04:05.279 --> 00:04:08.649
يبدو أنها تفعل ما توقعناه منها تماماً.

00:04:08.749 --> 00:04:12.219
ستسمر هذه الدالة بإرجاع القيمة "true"،

00:04:12.319 --> 00:04:16.089
جاعلة قيمة المتغيّر "on" تساوي "true"،
مطلقة بذلك صوت المنبّه

00:04:16.190 --> 00:04:18.192
إلى أن تُرجع دالة
"checkAlarm" القيمة "false"

00:04:18.292 --> 00:04:23.030
عندما يضغط شخص ما على زر الغفوة.

00:04:23.130 --> 00:04:27.201
ممتاز. تلاحظون الآن
أن استخدام حلقة "while"

00:04:27.301 --> 00:04:31.004
يمكنه تكرار شيء ما عدد متغير من المرات،

00:04:31.104 --> 00:04:35.242
وعليه لسنا بحاجة إلى أن نعرف مسبقاً عدد
المرات التي نحتاج فيها إلى تكرار فعل ما.

00:04:35.342 --> 00:04:38.512
كل ما علينا فعله هو وضعه في حلقة "while"
والتأكد من أن نتيجة تقييم الشرط

00:04:38.612 --> 00:04:42.015
ستؤول إلى "false"
في نهاية المطاف لكي تنكسر الحلقة.

00:04:42.115 --> 00:04:44.251
دعونا نتناول المزيد من الأمثلة.

