WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.580
现在我们已经想出办法来统计

00:00:02.580 --> 00:00:04.734
让两个骰子点数相同要投掷的次数

00:00:04.735 --> 00:00:07.800
现在来看看给问题加一个骰子后

00:00:07.799 --> 00:00:11.870
要怎么才能统计出让三个骰子点数相同的投掷次数

00:00:11.869 --> 00:00:16.500
首先我们需要在这里再声明一个整数变量 dice3

00:00:16.500 --> 00:00:21.535
再次调用 rollDice 函数 将其返回的值赋给 dice3

00:00:21.535 --> 00:00:23.789
在 while 循环里也要这么操作

00:00:23.789 --> 00:00:25.859
重掷三个骰子的时候

00:00:25.859 --> 00:00:30.539
我们需要再调用 rollDice 函数并将其值赋给 dice3

00:00:30.539 --> 00:00:32.519
最后我们需要修改这个 while 循环条件

00:00:32.520 --> 00:00:36.930
判断三个骰子点数是否相同

00:00:36.929 --> 00:00:38.750
而不是判断两个

00:00:38.750 --> 00:00:41.789
不幸的是 我们不能像这样做

00:00:41.789 --> 00:00:44.524
比如直接说 dice1 等于 dice2 等于 dice3

00:00:44.524 --> 00:00:48.420
Java 里的任何比较都只能有两边

00:00:48.420 --> 00:00:50.460
否则 Java 会报错

00:00:50.460 --> 00:00:53.785
不让你执行那段代码

00:00:53.784 --> 00:00:56.399
不过我们可以用之前学到的逻辑运算

00:00:56.399 --> 00:00:58.890
把这个判断拆分成若干个 放到一个条件里

00:00:58.890 --> 00:01:04.379
就像这些选项

00:01:04.379 --> 00:01:07.329
这些选项在 Java 里都是正确的

00:01:07.329 --> 00:01:11.965
但只有一个能使循环按我们的想法执行

00:01:11.965 --> 00:01:15.890
你觉得这个循环该用哪个条件呢？

00:01:15.890 --> 00:01:18.724
记住 我们想在三个骰子点数不全相同的时候

00:01:18.724 --> 00:01:21.979
不断执行循环

00:01:21.980 --> 00:01:23.120
也就是说

00:01:23.120 --> 00:01:25.070
如果三个骰子点数完全相同

00:01:25.069 --> 00:01:27.409
循环就会停止

