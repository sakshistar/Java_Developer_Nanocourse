WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.144
现在我们来看看要如何实现这个函数

00:00:04.144 --> 00:00:07.469
它接受了一个参数 也就是一个叫 names 的字符串数组

00:00:07.469 --> 00:00:12.739
并返回一个字符串 也就是函数在数组中找到的最长名称

00:00:12.740 --> 00:00:15.255
首先我们要计算数组的长度

00:00:15.255 --> 00:00:18.870
并将长度赋值给变量 size

00:00:18.870 --> 00:00:21.929
这样我们就能知道数组里有多少个元素了

00:00:21.929 --> 00:00:25.410
然后 基于这一点创建循环

00:00:25.410 --> 00:00:28.679
我们要做的第二件事是初始化变量 longestName

00:00:28.679 --> 00:00:33.024
我们也能管该变量叫其它名称 反正作用就是存储到目前为止我们找到的最长名称

00:00:33.024 --> 00:00:35.549
将该变量初始化为 names [0] 的值

00:00:35.549 --> 00:00:37.969
也就是数组的第一个名称

00:00:37.969 --> 00:00:41.115
之后 创建循环 使其从 1 开始

00:00:41.115 --> 00:00:43.730
也就是这之后的下一个名称

00:00:43.729 --> 00:00:47.834
循环计数器在到达数组大小之前 不会停止执行

00:00:47.835 --> 00:00:50.594
增量一如既往为 i++

00:00:50.594 --> 00:00:53.820
在循环里 我们得把数组内每个元素的长度

00:00:53.820 --> 00:00:59.134
与到目前为止我们找到的最长名称的长度进行比较

00:00:59.134 --> 00:01:01.710
所以这么写 if (names [i]

00:01:01.710 --> 00:01:07.849
names [i] 即数组位置 i 上的元素中的字符串

00:01:07.849 --> 00:01:10.487
我们写 if (names [i] . length

00:01:10.487 --> 00:01:13.319
也就是我们要衡量出相应字符串的长度

00:01:13.319 --> 00:01:18.029
将其与 longestName.length 进行比较

00:01:18.030 --> 00:01:22.189
而 longestName.length 存放的是到目前为止我们找到的最长名称

00:01:22.189 --> 00:01:27.060
所以如果 name .length 大于 longestName.length

00:01:27.060 --> 00:01:31.200
那么就把 longestName 更新为该名称

00:01:31.200 --> 00:01:34.995
这很像是在找数组里的最小值

00:01:34.995 --> 00:01:39.510
除了一点 我们是在进行大于的比较 而不是小于

00:01:39.510 --> 00:01:41.295
完成循环后

00:01:41.295 --> 00:01:44.879
也就意味着我们访问了数组里的每个元素

00:01:44.879 --> 00:01:48.655
而且每当我们找到更长的名称 我们就对 longestName 进行了更新

00:01:48.655 --> 00:01:53.560
于是我们可以安全地返回出 longestName 好了

