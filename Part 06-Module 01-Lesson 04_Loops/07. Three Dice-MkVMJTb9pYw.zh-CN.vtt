WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.225
正确答案是这个选项

00:00:03.225 --> 00:00:08.714
也就是当非 dice1 等于 dice2 且 dice2 等于 dice3 时

00:00:08.714 --> 00:00:13.655
我们一个个选项来试 看看为什么只有这个奏效

00:00:13.654 --> 00:00:15.519
先试试这个条件

00:00:15.519 --> 00:00:19.689
当 dice1 等于 dice2 或 dice2 等于 dice3 时

00:00:19.690 --> 00:00:24.895
想象这么个情景 三个骰子点数分别为 6、3 和 1

00:00:24.894 --> 00:00:27.475
也就是说 dice1 为 6

00:00:27.475 --> 00:00:31.615
dice2 为 3 dice3 为 1

00:00:31.614 --> 00:00:34.098
要知道这整个条件会怎么判断

00:00:34.098 --> 00:00:35.994
我们把它拆开来看

00:00:35.994 --> 00:00:38.530
这个部分判断的是 dice1 是否等于 dice2

00:00:38.530 --> 00:00:42.009
这里不等于 所以条件为假

00:00:42.009 --> 00:00:46.570
这个部分是判断 dice2 是否等于 dice3 不是

00:00:46.570 --> 00:00:47.965
所以也为假

00:00:47.965 --> 00:00:51.610
因为两个假值由 or 分隔开

00:00:51.609 --> 00:00:54.564
所以整个条件为假

00:00:54.564 --> 00:00:57.579
也就是说我们不会进入 while 循环

00:00:57.579 --> 00:01:01.619
不会重掷骰子 而这个情景其实是需要重掷的

00:01:01.619 --> 00:01:04.670
也就意味着这个条件不行

00:01:04.670 --> 00:01:07.445
好了 试试这个条件

00:01:07.444 --> 00:01:08.729
dice1 等于 dice2

00:01:08.730 --> 00:01:11.859
且 dice2 等于 dice3

00:01:11.859 --> 00:01:13.810
重复上面的情景

00:01:13.810 --> 00:01:15.189
也就是 dice1 为 6

00:01:15.189 --> 00:01:18.435
dice2 为 3 dice3 为 1

00:01:18.435 --> 00:01:22.250
这个部分会被判断为假 这个部分也会被判为假

00:01:22.250 --> 00:01:24.790
两个假值由 and 分隔开

00:01:24.790 --> 00:01:28.005
也就意味着整个条件为假

00:01:28.004 --> 00:01:29.784
所以也不会重掷

00:01:29.784 --> 00:01:31.774
而这个场景就得重掷

00:01:31.775 --> 00:01:33.910
所以这个条件也不行

00:01:33.909 --> 00:01:41.688
好了 来试试当 dice1 不等于 dice2 且 dice2 不等于 dice3 的条件

00:01:41.688 --> 00:01:43.969
再来试试那个情景

00:01:43.969 --> 00:01:45.310
dice1 为 6

00:01:45.310 --> 00:01:49.450
dice2 为 3 dice3 为 1

00:01:49.450 --> 00:01:53.140
现在判断 dice1 是否不等于 dice2

00:01:53.140 --> 00:01:56.140
不相等 所以判断结果为真

00:01:56.140 --> 00:01:59.260
这也是要判断是否不相等 3 和 1 不相等

00:01:59.260 --> 00:02:01.079
所以判断结果也为真

00:02:01.079 --> 00:02:03.807
两个真由 and 分隔开

00:02:03.808 --> 00:02:07.600
所以整个条件为真 我们可以重掷

00:02:07.599 --> 00:02:10.844
而这个情景里 我们就该重掷 所以很完美

00:02:10.844 --> 00:02:14.775
但如果情景是这样的呢？

00:02:14.775 --> 00:02:18.335
我们有两个 3 一个 1

00:02:18.335 --> 00:02:20.515
这种情况下 dice1 是 3

00:02:20.514 --> 00:02:24.304
dice2 也会是 3 而 dice3 是 1

00:02:24.305 --> 00:02:26.379
所以如果我们看这部分的话

00:02:26.379 --> 00:02:29.979
它会判断 dice1 和 dice2 是否不相同 而它们是相同的

00:02:29.979 --> 00:02:31.784
所以判断结果为假

00:02:31.784 --> 00:02:35.835
这部分判断它们是否不相同 它们的确不相同 所以结果为真

00:02:35.835 --> 00:02:38.860
可是假与真中间由 and 连接

00:02:38.860 --> 00:02:42.430
也就意味着其中一个为假 整个条件都会为假

00:02:42.430 --> 00:02:46.870
不会进入循环重掷 哪怕应该进入

00:02:46.870 --> 00:02:48.855
所以这个条件有时会奏效

00:02:48.854 --> 00:02:52.524
有时虽然该重掷 却不允许我们重掷

00:02:52.525 --> 00:02:54.295
所以也不行

00:02:54.294 --> 00:03:01.319
最后 我们来试试 当非 dice1 等于 dice2 且 dice2 等于 dice3 时这个条件

00:03:01.319 --> 00:03:03.489
还是用这个情景

00:03:03.490 --> 00:03:04.580
3、3 和 1

00:03:04.580 --> 00:03:05.965
dice1 为 3

00:03:05.965 --> 00:03:07.608
dice2 也为 3

00:03:07.608 --> 00:03:09.780
而 dice3 是 1

00:03:09.780 --> 00:03:13.895
经判断 这个部分为真 因为两个点数相同

00:03:13.895 --> 00:03:16.570
这个部分为假 因为 3 和 1 不同

00:03:16.569 --> 00:03:19.623
由于两边由 and 连接

00:03:19.623 --> 00:03:23.469
所以一真一假判为假

00:03:23.469 --> 00:03:25.335
但这整个由 not 括起来了

00:03:25.335 --> 00:03:28.435
也就意味着这个假会变为真

00:03:28.435 --> 00:03:31.944
这种情况下 循环会执行内部代码 重掷骰子

00:03:31.944 --> 00:03:35.239
现在你可以试试你能想到的其它情景

00:03:35.240 --> 00:03:38.580
只要是需要进入 while 循环的情景 它都会进入

00:03:38.580 --> 00:03:42.250
我们来看看这个情景 三个骰子点数相同

00:03:42.250 --> 00:03:45.365
这个时候 while 就不需要重掷了

00:03:45.365 --> 00:03:49.200
这个时候所有骰子点数都为 3

00:03:49.199 --> 00:03:54.209
先判断这个部分 结果为真 因为都是 3

00:03:54.210 --> 00:03:57.042
然后这个部分也为真 两个真由 and 连接

00:03:57.042 --> 00:04:00.509
所以结果为真

00:04:00.509 --> 00:04:05.049
由于前面还有个 not 也就意味着真会变为假

00:04:05.050 --> 00:04:07.960
而这个情景中 我们就是不想进入循环

00:04:07.960 --> 00:04:11.825
实际上这个判断结果也不会进入循环

00:04:11.824 --> 00:04:13.539
所以这个条件可用

