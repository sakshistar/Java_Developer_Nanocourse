WEBVTT
Kind: captions
Language: ar

00:00:00.000 --> 00:00:03.136
الجواب الصحيح هو عبارة التحقّق هذه.

00:00:03.237 --> 00:00:08.609
While(!(dice1 == dice2 &amp;&amp; dice2 == dice3)).

00:00:08.709 --> 00:00:13.547
لنجرّب كافة الخيارات واحدة تلو واحدة لنعرف
لماذا هذه هي العبارة الوحيدة التي ستعمل.

00:00:13.647 --> 00:00:15.415
لنجرّب هذا الشرط هنا.

00:00:15.516 --> 00:00:19.586
While(dice1 == dice2 || dice2 == dice3).

00:00:19.686 --> 00:00:24.791
تخيّلوا أن لدينا المشهد التالي
حيث قيم أحجار النرد الثلاثة هي 6 و3 و1.

00:00:24.892 --> 00:00:27.361
ما يعني أن dice1 يساوي 6،

00:00:27.461 --> 00:00:31.498
وdice2 يساوي 3، وdice3 يساوي 1.

00:00:31.598 --> 00:00:34.001
لنرى نتيجة هذا الشرط بالكامل،

00:00:34.101 --> 00:00:35.903
لنتناوله جزءاً جزءاً.

00:00:36.003 --> 00:00:38.438
يتحقق هذا الجزء
مما إذا كان dice1 مساوياً لـdice2

00:00:38.539 --> 00:00:41.909
وهما ليسا متساويين،
فستكون القيمة هنا هي false.

00:00:42.009 --> 00:00:46.480
ويتحقق هذا الجزء مما إذا كان dice2
مساوياً لـdice3، وهما ليسا متساويين،

00:00:46.580 --> 00:00:47.881
فقيمة ذلك هي false أيضاً.

00:00:47.981 --> 00:00:51.518
ولأن قيمتيّ false هاتين مفصولتين بعلامة or،

00:00:51.618 --> 00:00:54.454
فإن قيمة هذه العبارة بالكامل تصبح false،

00:00:54.555 --> 00:00:57.491
هذا يعني أننا لن ندخل حلقة while

00:00:57.591 --> 00:01:01.595
ولن نعيد رمي أحجار النرد على الرغم
من أنه كان ينبغي أن تسمح لنا هذه الحالة بذلك.

00:01:01.695 --> 00:01:04.631
هذا يعني أن هذا الشرط لن يعمل.

00:01:04.731 --> 00:01:07.401
حسناً، لنجرّب هذا الشرط بدلاً منه.

00:01:07.501 --> 00:01:11.839
dice1 == dice2 &amp;&amp; dice2 == dice3.

00:01:11.939 --> 00:01:13.774
إذا مررنا بالحالة نفسها مرة أخرى،

00:01:13.874 --> 00:01:15.142
بحيث أن dice1 يساوي 6،

00:01:15.242 --> 00:01:18.412
وdice2 يساوي 3، وdice3 يساوي 1.

00:01:18.512 --> 00:01:22.216
سيكون ناتج تقييم هذا الجزء false
وسيكون ناتج تقييم هذا الجزء false أيضاً.

00:01:22.316 --> 00:01:24.751
وقيمتا false هاتان مفصولتين بعلامة AND،

00:01:24.852 --> 00:01:27.955
ما يعني أنه سيكون
ناتج تقييم العبارة بالكامل هو false.

00:01:28.055 --> 00:01:29.756
فلن تتم إعادة رمي أحجار النرد.

00:01:29.857 --> 00:01:31.725
وكان ينبغي أن يحدث ذلك في هذه الحالة،

00:01:31.825 --> 00:01:33.861
لذا، لن تعمل هذه العبارة أيضاً.

00:01:33.961 --> 00:01:41.668
حسناً، لنجرّب
while(dice1 != dice2 &amp;&amp; dice2 != dice3).

00:01:41.768 --> 00:01:43.937
لنرجّب هذه الحالة مرة أخرى،

00:01:44.037 --> 00:01:45.272
حيث dice1 يساوي 6،

00:01:45.372 --> 00:01:49.409
وdice2 يساوي 3، وdice3 يساوي 1.

00:01:49.510 --> 00:01:53.113
هذه تتحقق مما إذا كانت dice1 لا يساوي dice2،

00:01:53.213 --> 00:01:56.116
وهما ليسا متساويين،
فيكون ناتج التقييم هو true.

00:01:56.216 --> 00:01:59.219
تتحقق هذه أيضاً ما إذا كانا غير متساويين،
و3 لا تساوي 1 بالفعل،

00:01:59.319 --> 00:02:01.121
فيكون ناتج تقييم الشرط هنا هو true أيضاً.

00:02:01.221 --> 00:02:03.857
وتفصل علامة AND قيمتي true هاتين،

00:02:03.957 --> 00:02:07.628
فناتج تقييم هذا الشرط بأكمله هو true
وسيسمح لنا بإعادة الرمي.

00:02:07.728 --> 00:02:10.864
ويجدر بنا إعادة الرمي
في هذه الحالة، فهذا ممتاز.

00:02:10.964 --> 00:02:14.801
لكن ماذا لو كانت الحالة شبيهة بما يلي؟

00:02:14.902 --> 00:02:18.372
حيث لدينا قيمتان مقدارهما 3
وقيمة واحدة مقدارها 1.

00:02:18.472 --> 00:02:20.541
في هذه الحالة، dice1 سيساوي 3،

00:02:20.641 --> 00:02:24.344
وdice2 سيساوي 2، وdice3 سيساوي 1.

00:02:24.444 --> 00:02:26.413
لذا، إذا نظرنا إلى هذا الجزء هنا،

00:02:26.513 --> 00:02:30.017
فسيكون ناتج تقييمه أن dice1 وdice2
ليسا متساويين، بالرغم من أنهما كذلك،

00:02:30.117 --> 00:02:31.818
فستكون قيمة هذا الشرط هي false.

00:02:31.919 --> 00:02:35.856
ويتحقق هذا الجزء مما إذا كانا غير متساويين،
وهما ليسا كذلك، وبالتالي تكون قيمته true.

00:02:35.956 --> 00:02:38.892
لكن تفصل إشارة AND بين false وtrue،

00:02:38.992 --> 00:02:42.462
ما يعني أنه بما أن إحدى القيمتين هي false
فبالتالي تصبح قيمة العبارة بأكملها false،

00:02:42.563 --> 00:02:46.900
وهذا لن يسمح لنا بإعادة الرمي
بالرغم من أنه كان من المفترض أن يفعل ذلك.

00:02:47.000 --> 00:02:48.902
هذا الخيار يقوم بالمطلوب جزئياً

00:02:49.002 --> 00:02:52.573
لكنه في بعض الحالات
لن يسمح لنا بإعادة الرمي عندما يجدر بنا ذلك.

00:02:52.673 --> 00:02:54.341
لذا، لن ينفع هذا الخيار أيضاً.

00:02:54.441 --> 00:03:01.415
وأخيراً، إن جرّبنا
While(!(dice1 == dice2 &amp;&amp; dice2 == dice3))،

00:03:01.515 --> 00:03:03.584
لنجرّب هذه الحالة مجدداً.

00:03:03.684 --> 00:03:04.685
3 و3 و1.

00:03:04.785 --> 00:03:06.053
أي أن dice1 يساوي 3،

00:03:06.153 --> 00:03:07.721
وdice2 يساوي 3 أيضاً،

00:03:07.821 --> 00:03:09.890
وdice3 يساوي 1.

00:03:09.990 --> 00:03:13.994
يكون ناتج تقييم هذا الجزء هو true
لأن حجريّ النرد هذين متساويان.

00:03:14.094 --> 00:03:16.663
ويكون ناتج تقييم هذا الجزء هو false
لأن 3 و1 مختلفان عن بعضهما،

00:03:16.763 --> 00:03:19.733
والجزآن مفصولان بإشارة AND،

00:03:19.833 --> 00:03:23.570
فيكون ناتج تقييم true وfalse هي false.

00:03:23.670 --> 00:03:25.439
لكن هذه العبارة بأكملها محاطة بإشارة NOT،

00:03:25.539 --> 00:03:28.542
ما يعني أن قيمة false هذه ستتحوّل إلى true.

00:03:28.642 --> 00:03:32.045
وفي هذه الحالة،
سندخل في الحلقة التي ستعيد الرمي.

00:03:32.145 --> 00:03:35.349
يمكنكم الآن أن تجربوا
جميع الحالات المختلفة التي يمكنك التفكير بها.

00:03:35.449 --> 00:03:38.685
وكلما يتوجب عليها
الدخول في حلقة while، ستدخل بالفعل.

00:03:38.785 --> 00:03:42.356
لنلقِ نظرة على حالة
تتساوى فيها الأحجار الثلاثة،

00:03:42.456 --> 00:03:45.459
وهي حالة لا يتوجب فيها
على حلقة while أن تعيد الرمي.

00:03:45.559 --> 00:03:49.296
في هذه الحالة،
جميع أحجار النرد تحمل القيمة 3.

00:03:49.396 --> 00:03:54.301
فعندما نبدأ في إيجاد ناتج التقييم، يكون ناتج
تقييم هذا الجزء هو true لأن قيمة كليهما 3.

00:03:54.401 --> 00:03:57.137
وناتج تقييم هذا أيضاً هو true،
وهكذا فإن قيمتيّ true

00:03:57.237 --> 00:04:00.674
تفصل بينهما إشارة AND
يكون ناتج تقييمها هو true بالكامل.

00:04:00.774 --> 00:04:05.212
وذلك كله محاط بإشارة NOT،
ما يعني أن هذه القيمة تصبح false.

00:04:05.312 --> 00:04:08.115
لا نريد دخول الحلقة في هذه الحالةـ

00:04:08.215 --> 00:04:11.985
وهذا بالضبط ما يحدث هنا مع شرط التحقق هذا.

00:04:12.085 --> 00:04:13.820
إذن، إنه يعمل مع هذه الحالة أيضاً.

