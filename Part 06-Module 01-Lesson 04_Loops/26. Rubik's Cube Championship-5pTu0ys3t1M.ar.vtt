WEBVTT
Kind: captions
Language: ar

00:00:40.107 --> 00:00:42.743
خلال أقل من دقيقة فقط.

00:00:42.843 --> 00:00:45.379
لكن هذا ليس مبهراً كثيراً
مقارنة بما يستغرقه

00:00:45.479 --> 00:00:48.282
أي من أبطال العالم لحلها.

00:00:48.382 --> 00:00:52.186
يستطيع محترفو حل مكعّب "روبيك" السريع
القيام بذلك خلال أقل من 10 ثوان.

00:00:52.286 --> 00:00:54.588
ويتطلّب الأمر الكثير من التدريب والحفظ،

00:00:54.688 --> 00:00:56.757
وأنامل سريعة جداً.

00:00:56.857 --> 00:01:00.694
هذا مثال على بعض أسرع
أوقات الحل التي تم تسجيلها رسمياً.

00:01:00.794 --> 00:01:03.764
هل يمكنك إيجاد أسرع شخص في الجدول؟

00:01:03.864 --> 00:01:06.767
إنه "لوكاس إيتر"
فتى في الـ14 من العمر من "كنتاكي"،

00:01:06.867 --> 00:01:11.338
في "الولايات المتحدة"،
وهو صاحب أكبر رقم قياسي في العام 2015،

00:01:11.438 --> 00:01:13.540
عن أسرع وقت في حل مكعّب "روبيك"،

00:01:13.640 --> 00:01:17.277
كاسراً بذلك حاجز الخمس ثوان
للمرة الأولى على الإطلاق.

00:01:17.377 --> 00:01:19.546
لكن، لنعد إلى قائمة المتصدرين تلك.

00:01:19.646 --> 00:01:23.183
أريدكم أن تفكروا في الكيفية التي
اتبعتموها للعثور على اللاعب الأسرع.

00:01:23.283 --> 00:01:26.620
أعرف أن ذلك يبدو بديهياً جداً لنا
نحن البشر، لكن ماذا لو أردنا كتابة

00:01:26.720 --> 00:01:31.191
دالة تجد العدد الأصغر ضمن مصفوفة كهذه؟

00:01:31.291 --> 00:01:35.562
إذن، لنلقِ نظرة إلية آلية
عمل عقولنا عندما نبحث

00:01:35.662 --> 00:01:40.801
عن العدد الأصغر ضمن قائمة من الأعداد
كما في قائمة المتصدرين مثلاً.

00:01:40.901 --> 00:01:44.304
لدي هنا مصفوفة من الأعداد
من نوع "double" اسمها "speed".

00:01:44.404 --> 00:01:46.406
وهي تحتوى على هذه الأعداد

00:01:46.507 --> 00:01:49.109
التي تقابلها مؤشرات فهرسة من صفر إلى 6.

00:01:49.209 --> 00:01:51.845
للعثور على العدد الأصغر هنا،

00:01:51.945 --> 00:01:55.015
يجب علي فحصها واحدة تلو الأخرى،

00:01:55.115 --> 00:01:59.019
وتذكر العدد الأصغر
الذي وجدته حتى تلك اللحظة فقط.

00:01:59.119 --> 00:02:01.588
سأخزن أصغر عدد رأيته حتى الآن

00:02:01.688 --> 00:02:05.292
في هذا المتغيّر المسمى "min"،
اختصاراً لـ"minimum" أي "القيمة الصغرى".

00:02:05.392 --> 00:02:07.394
لنبدأ من البداية.

00:02:07.494 --> 00:02:10.197
القيمة الأولى هنا هي 7,85.

00:02:10.297 --> 00:02:12.132
وهي أصغر قيمة رأيناها حتى الآن،

00:02:12.232 --> 00:02:14.535
لذا سنخزنها في المتغيّر "min".

00:02:14.635 --> 00:02:16.637
ثم نتابع.

00:02:16.737 --> 00:02:20.707
القيمة الثانية هي 7,32،

00:02:20.807 --> 00:02:24.344
لذا أسأل نفسي،
هل قيمة المصفوفة "speed" المقابلة للمؤشر 1

00:02:24.444 --> 00:02:29.316
أي هذه الخانة،
أصغر من القيمة الصغرى التي لدينا؟

00:02:29.416 --> 00:02:35.689
أجل هي كذلك، لذا سأحدّث المتغير "min"
وأخزن القيمة الجديدة فيه،

00:02:35.789 --> 00:02:40.294
وهي 7,32. ثم أتابع.

00:02:40.394 --> 00:02:43.430
ثم أسأل نفسي مجدداً،

00:02:43.530 --> 00:02:46.733
هل قيمة المصفوفة "speed" المقابلة للمؤشر 2
أقل من القيمة المخزنة في "min"?

00:02:46.834 --> 00:02:49.636
قيمة المصفوفة "speed"
المقابلة للمؤشر 2 هي 4,9،

00:02:49.736 --> 00:02:51.705
والقيمة الصغرى المخزنة في "min" هي 7,32.

00:02:51.805 --> 00:02:56.677
أجل هي أصغر منها، لذا أحدّث "min"
بوضع القيمة الجديدة فيها،

00:02:56.777 --> 00:03:01.281
وهي 4,9. ثم أتابع.

00:03:01.381 --> 00:03:03.250
أسأل نفسي مجدداً،

00:03:03.350 --> 00:03:05.552
هل قيمة المصفوفة "speed" المقابلة للمؤشر 3
أقل من القيمة في "min"؟

00:03:05.652 --> 00:03:09.890
القيمة عند المؤشر 3 هي 6,22،
بينما القيمة الصغرى هي 4,9.

00:03:09.990 --> 00:03:12.893
من الواضح أنها ليست أصغر منها،

00:03:12.993 --> 00:03:15.729
لذا لن أحدّث القيمة المخزنة في "min".

00:03:15.829 --> 00:03:18.932
أتابع، فأصل إلى 5,4،

00:03:19.032 --> 00:03:24.638
و5,4 ليست أقل من 4,9. لذا أتابع،

00:03:24.738 --> 00:03:29.209
والآن، 7,3 ليست أصغر من 4,9.

00:03:29.309 --> 00:03:31.078
لذا أتابع من جديد.

00:03:31.178 --> 00:03:35.249
5,19 هي الأخرى ليست أقل من القيمة الصغرى.

00:03:35.349 --> 00:03:41.822
إذن، فقد راجعت كافة عناصر المصفوفة،
والقيمة الصغرى التي وجدتها كانت 4,9.

00:03:41.922 --> 00:03:45.225
يسمى ما فعلناه هنا بالخوارزمية.

00:03:45.325 --> 00:03:48.228
وهي باختصار اتّباع عدد من الخطوات المنهجية

00:03:48.328 --> 00:03:51.131
حتى نصل إلى الإجابة الصحيحة التي ننشدها.

00:03:51.231 --> 00:03:54.401
إن التفكير
بهذه الطريقة يساعدنا في كتابة الكود.

00:03:54.501 --> 00:03:57.070
دعونا نرى كيف يمكننا تطبيق
هذا في لغة Java.

00:03:57.171 --> 00:03:59.907
لنفترض أننا نريد كتابة الكود
في صيغة دالة هكذا.

00:04:00.007 --> 00:04:01.575
دالة اسمها "search"،

00:04:01.675 --> 00:04:03.177
وهي تتلقى كمعلمة

00:04:03.277 --> 00:04:07.648
مصفوفة أعداد من نوع "double" اسمها "speed"
وتُرجع عدداً واحداً من نوع "double"،

00:04:07.748 --> 00:04:11.485
وهو أصغر قيمة في هذه المصفوفة.

00:04:11.585 --> 00:04:13.387
لذا فإن المعلمة هي المصفوفة "speed"،

00:04:13.487 --> 00:04:15.656
وهي مصفوفة أعداد من النوع "double"،

00:04:15.756 --> 00:04:19.726
وتُرجع عدداً من النوع "double"،
وهو أقصى سرعة تم العثور عليها.

00:04:19.826 --> 00:04:23.730
سأترك هذه هنا كمثال لنا لنتتبعها لاحقاً.

00:04:23.830 --> 00:04:31.171
أول ما علينا فعله هو إيجاد طول مصفوفتنا
وتخزينه في متغيّر اسمه "size".

00:04:31.271 --> 00:04:34.208
تحسب "array.length" عدد الخانات

00:04:34.308 --> 00:04:38.412
الموجودة في تلك المصفوفة
وتُرجع تلك القيمة في صيغة عدد من نوع "int",

00:04:38.512 --> 00:04:45.052
في هذه الحالة قيمة "size" للمصفوفة هي 7،
لأن لدينا سبع خانات في مصفوفتنا.

00:04:45.152 --> 00:04:47.721
الخطوة التالي
هي خلق متغيّر اسمه "min"،

00:04:47.821 --> 00:04:50.257
وهو كما تذكرون
سيحفظ العدد الأصغر أثناء بحثنا.

00:04:50.357 --> 00:04:53.694
سنسند إليه قيمة أول عنصر
في المصفوفة كقيمة أولية، وهي

00:04:53.794 --> 00:04:55.696
.speed[0]

00:04:55.796 --> 00:04:57.831
إذن، بعد تنفيذ هذا الأمر،

00:04:57.931 --> 00:05:02.135
ستكون قيمة المتغير "min" هي 7,85.

00:05:02.236 --> 00:05:04.938
لو كانت هناك مصفوفة أخرى
تم تمريرها كمعلمة

00:05:05.038 --> 00:05:09.209
فسوف يسترجع المتغيّر "min"
القيمة الأولى فيها أياً كانت.

00:05:09.309 --> 00:05:14.248
والآن علينا استخدام حلقة حتى نستطيع
المرور على جميع عناصر هذه المصفوفة.

00:05:14.348 --> 00:05:20.254
يتم إسناد الرقم 1 كقيمة أولية لعدّاد الحلقة
وشرطنا هو أن تكون "i" أصغر من "size".

00:05:20.354 --> 00:05:22.789
وهذا يعني أن العداد سيبدأ العد من 1،

00:05:22.890 --> 00:05:26.293
ويتصاعد وصولاً
إلى القيمة السابقة لقيمة "size".

00:05:26.393 --> 00:05:28.495
والزيادة هي "++i" فحسب،

00:05:28.595 --> 00:05:31.598
ما يعني أننا نضيف 1 فقط
إلى العداد في كل مرة.

00:05:31.698 --> 00:05:36.670
السبب في أننا بدأنا بالرقم واحد هو أننا
أسندنا قيمة العنصر الأول إلى "min" مسبقاً.

00:05:36.770 --> 00:05:41.842
لذا، علينا أن نبدأ المقارنة بالعنصر
ذي مؤشر الفهرس رقم 1 ونواصل حتى النهاية،

00:05:41.942 --> 00:05:44.912
أي حتى قيمة المتغير "size".
إذن، ماذا علينا أن نفعل؟

00:05:45.012 --> 00:05:47.748
نسأل أنفسنا
ونحن داخل الحلقة السؤال التالي:

00:05:47.848 --> 00:05:54.555
هل هذه القيمة في تلك المرحلة من الحلقة
أصغر من قيمة "min"؟

00:05:54.655 --> 00:05:56.456
نقوم بذلك باستخدام عبارة "if" شرطية.

00:05:56.557 --> 00:06:02.462
فنقول إذا كانت السرعة المقابلة للمؤشر "i"،
أي "speed[i]"، أقل من قيمة "min".

00:06:02.563 --> 00:06:09.069
تشير Speed[i] إلى خانة محددة
في المصفوفة وفقاً لقيمة "i".

00:06:09.169 --> 00:06:12.206
إذن، فهي تبدأ بالإشارة
إلى هذه الخانة تحديداً

00:06:12.306 --> 00:06:16.076
ثم تنتقل إلى هذه فهذه، وهكذا دواليك.

00:06:16.176 --> 00:06:18.645
ونقوم في كل مرة
بمقارنة تلك القيمة بقيمة "min".

00:06:18.745 --> 00:06:20.681
وإذا كانت أصغر من "min" بالفعل

00:06:20.781 --> 00:06:24.685
نقوم بتحديث قيمة المتغير "min"
بإسناد قيمة "speed[i]" إليه.

00:06:24.785 --> 00:06:26.587
وعندما تكتمل الحلقة

00:06:26.687 --> 00:06:29.857
أي عندما نكون قد مررنا
بكل خانة من خانات المصفوفة،

00:06:29.957 --> 00:06:31.892
يمكننا أن نرجع قيمة "min" فحسب.

00:06:31.992 --> 00:06:34.328
لأننا في هذه اللحظة متأكدون

00:06:34.428 --> 00:06:37.397
من أن المتغير "min"
يحمل القيمة الصغرى من قيم المصفوفة.

