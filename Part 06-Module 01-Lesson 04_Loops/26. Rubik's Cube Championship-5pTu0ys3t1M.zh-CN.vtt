WEBVTT
Kind: captions
Language: zh-CN

00:00:40.109 --> 00:00:42.854
刚好在一分钟内

00:00:42.854 --> 00:00:45.489
可这和其他复原魔方的世界冠军相比

00:00:45.490 --> 00:00:48.395
这个用时一点也不稀奇

00:00:48.395 --> 00:00:52.295
事实上 竞速玩家能在十秒内复原魔方

00:00:52.295 --> 00:00:54.685
这需要大量练习和记忆

00:00:54.685 --> 00:00:56.859
以及相当灵活的手指

00:00:56.859 --> 00:01:00.729
这是官方记下的一些最短耗时

00:01:00.729 --> 00:01:03.804
你能找出表格里最快的那个人吗？

00:01:03.804 --> 00:01:06.810
Lucas Etter 十四岁 来自美国肯塔基州

00:01:06.810 --> 00:01:11.365
他拥有2015年的一项世界纪录

00:01:11.364 --> 00:01:13.566
即魔方复原最短耗时记录

00:01:13.566 --> 00:01:17.314
首次打破了前人创下的五秒记录

00:01:17.314 --> 00:01:19.575
不过我们回到这里的排行榜来

00:01:19.575 --> 00:01:23.200
我想让你思考自己是如何找到最快玩家的

00:01:23.200 --> 00:01:26.650
我知道对我们人类来说 这很像直觉 但如果我们想创建一个函数

00:01:26.650 --> 00:01:31.234
让它从一个像这样的数组里找出最小值 那要怎么做呢？

00:01:31.233 --> 00:01:35.599
我们来看看人脑在一系列值中寻找最小值时 实际上是如何运转的

00:01:35.599 --> 00:01:40.849
以这个排行榜为例

00:01:40.849 --> 00:01:44.329
我这有个双精度数组 叫 speed

00:01:44.329 --> 00:01:46.454
里面包含了这些数字

00:01:46.454 --> 00:01:49.144
索引为 0 到 6

00:01:49.144 --> 00:01:51.864
要找出这里面的最小值

00:01:51.864 --> 00:01:55.039
我只需一个个看过去

00:01:55.040 --> 00:01:59.070
记住迄今为止看到的最小值即可

00:01:59.069 --> 00:02:05.244
我把迄今为止看到的最小值存放在这个变量 min 里 min 即最小值 minimum 的简称

00:02:05.245 --> 00:02:07.365
我们从头开始

00:02:07.364 --> 00:02:10.180
第一个值是 7.85

00:02:10.180 --> 00:02:12.090
这是目前我们看到的最小值

00:02:12.090 --> 00:02:14.515
于是将其赋给变量 min

00:02:14.514 --> 00:02:16.614
接着我们继续看

00:02:16.615 --> 00:02:20.675
第二个值是 7.32

00:02:20.675 --> 00:02:24.313
所以我会问这个问题 speed [1]

00:02:24.312 --> 00:02:29.274
也就是这个元素 是否小于我们的最小值？

00:02:29.275 --> 00:02:35.645
是的 所以更新最小值 使其变为新值

00:02:35.645 --> 00:02:40.245
即 7.32 接着继续看

00:02:40.245 --> 00:02:43.384
我再次问自己这个问题

00:02:43.384 --> 00:02:46.715
speed [2] 是否小于最小值？

00:02:46.715 --> 00:02:49.610
这里的 speed [2] 是 4.9

00:02:49.610 --> 00:02:51.685
而最小值是 7.32

00:02:51.685 --> 00:02:56.641
是的 所以将最小值更新为

00:02:56.641 --> 00:03:01.659
4.9 继续 接着

00:03:01.659 --> 00:03:03.159
我再问这个问题

00:03:03.159 --> 00:03:05.460
speed [3] 是否小于最小值？

00:03:05.460 --> 00:03:09.805
speed [3] 为 6.22 而最小值为 4.9

00:03:09.805 --> 00:03:12.800
显然不再小于最小值

00:03:12.800 --> 00:03:15.621
所以不更新最小值

00:03:15.621 --> 00:03:17.320
继续 接着

00:03:17.319 --> 00:03:19.930
我看到 5.4

00:03:19.930 --> 00:03:22.125
5.4 不小于 4.9

00:03:22.125 --> 00:03:24.534
所以我继续

00:03:24.534 --> 00:03:29.094
7.3 不小于 4.9

00:03:29.094 --> 00:03:30.990
所以我继续

00:03:30.990 --> 00:03:35.150
5.19 还是不小于最小值

00:03:35.150 --> 00:03:41.730
所以我看完了整个数组 找出了最小值 即 4.9

00:03:41.729 --> 00:03:45.119
我们刚做的这件事其实是个算法

00:03:45.120 --> 00:03:48.140
算法就是重复若干规律性步骤

00:03:48.139 --> 00:03:51.034
从而找出我们想要的正确答案

00:03:51.034 --> 00:03:54.289
这种思路能帮我们写出代码

00:03:54.289 --> 00:03:56.965
我们来看看如何在 Java 里实现这个操作

00:03:56.965 --> 00:03:59.810
假设我们要把该操作写成这么个函数

00:03:59.810 --> 00:04:01.400
函数叫做 search

00:04:01.400 --> 00:04:03.020
接受一个参数

00:04:03.020 --> 00:04:07.480
即一个双精度数组 名为 speed 之后函数会返回出一个双精度值

00:04:07.479 --> 00:04:11.324
也就是数组里最快的值 即最小值

00:04:11.324 --> 00:04:13.234
所以参数是这个 speed 数组

00:04:13.235 --> 00:04:15.475
它是个双精度数组

00:04:15.474 --> 00:04:19.550
函数会返回一个双精度值 也就是它找出的最快速度

00:04:19.550 --> 00:04:23.555
我就把这留在这里好了 为稍后的跟踪示例

00:04:23.555 --> 00:04:27.110
首先我们需要获取数组的长度

00:04:27.110 --> 00:04:31.009
并将长度存储为变量 size

00:04:31.009 --> 00:04:34.509
任何数组 . length 都会算出数组里有多少个元素

00:04:34.509 --> 00:04:38.235
并将计算结果作为一个整数返回出来

00:04:38.235 --> 00:04:44.895
我们这里的 size 是 7 因为我们数组里有 7 个元素

00:04:44.894 --> 00:04:47.569
下一步是创建一个叫 min 的变量

00:04:47.569 --> 00:04:50.074
记住 该变量始终会是最小值

00:04:50.074 --> 00:04:53.644
我们将其初始化为数组的第一项

00:04:53.644 --> 00:04:55.529
也就是 speed [0]

00:04:55.529 --> 00:04:57.679
这个指令执行后

00:04:57.680 --> 00:05:01.910
变量 min 就会是 7.85

00:05:01.910 --> 00:05:05.180
即便换一个数组当参数

00:05:05.180 --> 00:05:08.975
min 还是会抓取数组的第一项 无论那个值是什么

00:05:08.975 --> 00:05:14.000
接着 我们需要创建一个循环来对这个数组进行迭代

00:05:14.000 --> 00:05:20.004
将循环计数器初始化为 1 条件是 i 小于 size

00:05:20.004 --> 00:05:22.564
也就是说 计数器会从 1 开始计数

00:05:22.564 --> 00:05:26.045
一直计到 size 的值为止

00:05:26.045 --> 00:05:28.250
增量就为 i++

00:05:28.250 --> 00:05:31.355
也就是说 每次循环我们只加 1

00:05:31.355 --> 00:05:33.500
之所以从 1 开始

00:05:33.500 --> 00:05:36.420
是因为我们已经将最小值分配给了第一项

00:05:36.420 --> 00:05:41.600
所以我们需要从索引为 1 的项开始比较 直到最后

00:05:41.600 --> 00:05:44.695
也就是一直比较到 size 的大小为止 接下来要怎么做？

00:05:44.694 --> 00:05:47.514
在循环里 我们要问自己这个问题

00:05:47.514 --> 00:05:54.314
这时循环里的值是否小于最小值？

00:05:54.314 --> 00:05:56.500
用 if 条件来实现这一步

00:05:56.500 --> 00:06:02.175
输入 if (speed [i] &lt; min)

00:06:02.175 --> 00:06:09.030
speed [i] 指向数组内某一特定元素 至于是哪一个 由 i 的值决定

00:06:09.029 --> 00:06:11.914
所以一开始是指向这个元素

00:06:11.915 --> 00:06:15.765
然后移向这一个 依次类推

00:06:15.764 --> 00:06:18.360
每次我们都要将元素的值与最小值相比

00:06:18.360 --> 00:06:20.370
如果小于最小值

00:06:20.370 --> 00:06:24.375
那就将最小值更新为 speed [i] 的值

00:06:24.375 --> 00:06:26.279
一旦完成循环

00:06:26.279 --> 00:06:29.549
也就意味着我们访问了数组里的每个元素

00:06:29.550 --> 00:06:31.590
那我们就可以返回出最小值

00:06:31.589 --> 00:06:34.019
因为这个时候我们已经确定

00:06:34.019 --> 00:06:37.000
最小值会是数组里的最小值

