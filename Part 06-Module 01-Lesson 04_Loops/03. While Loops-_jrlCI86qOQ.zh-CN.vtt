WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.109
但就算我们决定

00:00:03.109 --> 00:00:07.275
比如说在一百次响铃后 不管有没有人关闹钟 我们都要把它关掉

00:00:07.275 --> 00:00:12.905
我们也得复制粘贴这个 if 模块一百次

00:00:12.904 --> 00:00:14.754
太麻烦了

00:00:14.755 --> 00:00:16.019
肯定有解决办法才对

00:00:16.019 --> 00:00:20.739
是吧？ Java 的确有解决办法 那就是循环

00:00:20.739 --> 00:00:22.484
我们来看看循环的工作原理

00:00:22.484 --> 00:00:25.544
在 Java 你可以不用 if

00:00:25.545 --> 00:00:27.925
而用 while

00:00:27.925 --> 00:00:30.780
它和 if 条件很类似

00:00:30.780 --> 00:00:33.825
不过比起 if 只进行一次条件判断

00:00:33.825 --> 00:00:38.469
while 会不断地判断条件 每做一次判断 只要条件为真

00:00:38.469 --> 00:00:40.884
它就会执行这个代码块

00:00:40.884 --> 00:00:43.109
因此 像这个代码块执行起来是这样的

00:00:43.109 --> 00:00:46.214
判断这个变量 on 是否为真

00:00:46.215 --> 00:00:48.015
变量为真时 它就会进到这里面

00:00:48.015 --> 00:00:49.740
执行这整个代码块

00:00:49.740 --> 00:00:52.380
然后回到这上面来 再对变量 on 进行判断

00:00:52.380 --> 00:00:55.035
如果还是真 那就再下来重复这个部分

00:00:55.034 --> 00:00:59.494
不断重复 直到 on 不再为真

00:00:59.494 --> 00:01:02.504
它就会跳出这一部分 继续往下

00:01:02.505 --> 00:01:05.219
这就是它被称为 while 循环的原因

00:01:05.219 --> 00:01:08.939
因为它会循环不断地执行这个代码块

00:01:08.939 --> 00:01:14.439
只要条件仍为真 就会不断地执行

00:01:14.439 --> 00:01:18.659
也就意味着仅仅是这么个 while 模块

00:01:18.659 --> 00:01:23.369
就可以取代这边所有重复的 if 模块

00:01:23.370 --> 00:01:28.770
所以我们不需要用多个 if 模块来对变量 on 进行多次判断

00:01:28.769 --> 00:01:31.219
只需用 while 循环来判断就好

00:01:31.219 --> 00:01:37.510
循环会一次次地重复执行这个代码块 直到 on 不再为真为止

00:01:37.510 --> 00:01:42.420
而由于我们用 checkAlarm 函数来更新这个 on 变量

00:01:42.420 --> 00:01:44.379
所以等有人关掉了闹钟 这个 checkAlarm 函数

00:01:44.379 --> 00:01:46.893
会将结果返回为假值

00:01:46.893 --> 00:01:49.010
使变量 on 变为假

00:01:49.010 --> 00:01:52.880
所以这个 while 模块总有停止的时候

00:01:52.879 --> 00:01:57.890
我们来跟踪这个用 while 循环的函数 看看会怎么样

00:01:57.890 --> 00:02:00.195
修改后的函数像这样

00:02:00.194 --> 00:02:03.289
我们先来创建这个布尔变量 on

00:02:03.290 --> 00:02:07.355
然后进行响铃检查 之后 我们不用那些重复的 if 模块了

00:02:07.355 --> 00:02:12.920
只用这个 while 循环 检查 on 是否为真

00:02:12.919 --> 00:02:19.509
如果为真 就让闹钟响铃 然后再次用 checkAlarm 函数更新 on 值

00:02:19.509 --> 00:02:22.310
记住 checkAlarm 函数返回的布尔值

00:02:22.310 --> 00:02:25.670
如果闹钟响着 就会为真

00:02:25.669 --> 00:02:27.764
如果闹钟被关掉了 就会为假

00:02:27.764 --> 00:02:29.959
我们来试试这个函数 看看怎么样

00:02:29.960 --> 00:02:35.205
首先我们调用 checkAlarm 函数 把变量 on 初始化

00:02:35.205 --> 00:02:37.309
因为现在是 6 点

00:02:37.308 --> 00:02:39.650
所以 checkAlarm 返回的结果为真

00:02:39.650 --> 00:02:42.590
也就是说闹钟现在开始响了

00:02:42.590 --> 00:02:45.185
于是这里的变量 on 为真

00:02:45.185 --> 00:02:49.490
也就是 while 会判断条件为真

00:02:49.490 --> 00:02:52.700
所以它会进入循环 开始响铃

00:02:52.699 --> 00:02:57.019
也就是说 现实里它会促使闹钟响铃

00:02:57.020 --> 00:03:01.425
然后 再检查一次响铃 更新变量 on

00:03:01.425 --> 00:03:03.314
因为现在还没人按下打盹按钮

00:03:03.314 --> 00:03:05.780
所以 checkAlarm 仍为真

00:03:05.780 --> 00:03:09.504
使得变量 on 为真

00:03:09.504 --> 00:03:11.432
到达循环尾部

00:03:11.432 --> 00:03:15.049
再回来 再检查 on 是否为真

00:03:15.050 --> 00:03:16.963
因为 on 为真

00:03:16.962 --> 00:03:20.829
所以再次进入循环 调用 beep 函数

00:03:20.830 --> 00:03:23.375
再次触发闹钟铃声

00:03:23.375 --> 00:03:26.780
再次检查响铃

00:03:26.780 --> 00:03:30.710
现在 想象有人按下了打盹按钮

00:03:30.710 --> 00:03:34.775
意味着当我们调用 checkAlarm 函数来检查闹钟是否还在响铃时

00:03:34.775 --> 00:03:38.210
函数返回的结果会为假

00:03:38.210 --> 00:03:41.135
因此 on 变为假

00:03:41.134 --> 00:03:43.250
所以我们到了循环尾部

00:03:43.250 --> 00:03:46.060
再回来 再次进行判断

00:03:46.060 --> 00:03:49.550
由于 while 条件不再为真

00:03:49.550 --> 00:03:53.240
我们不进入循环 因此闹钟不响

00:03:53.240 --> 00:03:55.015
接下来什么也不会发生了

00:03:55.014 --> 00:03:58.047
也就是说 while 循环结束了

00:03:58.048 --> 00:03:59.960
不会再进行判断或执行代码了

00:03:59.960 --> 00:04:05.010
函数会继续往下执行 但下面什么都没有了 所以函数结束

00:04:05.009 --> 00:04:08.625
似乎函数完全按我们预想进行了呢

00:04:08.625 --> 00:04:12.060
这会持续返回真值

00:04:12.060 --> 00:04:14.175
将变量 on 设为真

00:04:14.175 --> 00:04:18.020
使得闹钟一直响铃

00:04:18.019 --> 00:04:23.089
直到有人按下了打盹按钮 checkAlarm 终于决定返回假值

00:04:23.089 --> 00:04:28.294
完美 你现在了解了吧 使用 while 循环可以重复

00:04:28.295 --> 00:04:31.520
若干次

00:04:31.519 --> 00:04:35.074
而我们并不需要提前知道这得重复多少次

00:04:35.074 --> 00:04:37.639
只需把事件放到 while 循环里

00:04:37.639 --> 00:04:42.110
确保条件总有变为假并结束循环的时候就行

00:04:42.110 --> 00:04:44.000
我们来看更多案例

