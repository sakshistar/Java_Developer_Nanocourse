WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.849
很多情况下 你可能想在循环正常结束之前就让它停止

00:00:04.849 --> 00:00:06.945
我们来看一个案例

00:00:06.945 --> 00:00:09.720
想象你在写一个程序

00:00:09.720 --> 00:00:13.200
该程序会控制你的智能手机来搜寻附近的 Wi-Fi 网络

00:00:13.199 --> 00:00:17.799
你想重试十次 然后停止搜寻

00:00:17.800 --> 00:00:23.905
所以我们创建了一个循环 i 从 1 开始计数 一直到 10 每次增量为 1

00:00:23.905 --> 00:00:28.385
所以循环里无论有什么指令 都会整整重复执行 10 次

00:00:28.385 --> 00:00:30.290
在循环里

00:00:30.289 --> 00:00:32.089
我们调用这个函数

00:00:32.090 --> 00:00:34.265
叫做 checkWifi

00:00:34.265 --> 00:00:36.375
假设这个函数实现时会进行一次 Wi-Fi 查找

00:00:36.375 --> 00:00:40.549
如果找到了一个 Wi-Fi 函数就会返回真值

00:00:40.549 --> 00:00:42.859
所以我们要将这个函数的返回值赋给这里的布尔

00:00:42.859 --> 00:00:47.329
该布尔叫做 wifiAvailable

00:00:47.329 --> 00:00:49.864
也就是说 如果这个布尔值为真

00:00:49.865 --> 00:00:52.950
那就意味着我们成功地找到了一个 Wi-Fi 网络

00:00:52.950 --> 00:00:57.425
如果为假 那就还没找到 得继续找

00:00:57.424 --> 00:01:03.519
在这之后 我们加上这么个 if 条件 判断这个变量是否为真

00:01:03.520 --> 00:01:08.655
如果是 那就输出 Wifi found 函数结束

00:01:08.655 --> 00:01:09.950
如果不是

00:01:09.950 --> 00:01:15.775
那就继续在 for 循环里循环 按我们设想的那样循环十次

00:01:15.775 --> 00:01:21.475
这段代码会重复十次 直到找到了网络或者十次都找不到

00:01:21.474 --> 00:01:23.208
看起来很棒了

00:01:23.209 --> 00:01:26.799
除非发生一个奇怪的情景

00:01:26.799 --> 00:01:31.554
如果我们在循环尚未结束时就找到了 Wi-Fi 网络

00:01:31.555 --> 00:01:34.355
假设是第五次迭代

00:01:34.355 --> 00:01:36.920
想象在第五次迭代的时候

00:01:36.920 --> 00:01:40.109
我们的 checkWifi 函数返回了真值

00:01:40.109 --> 00:01:42.935
使变量更新为真

00:01:42.935 --> 00:01:47.385
于是我们进入这里的 if 条件 输出 Wifi found

00:01:47.385 --> 00:01:49.180
之后 if 条件就结束了

00:01:49.180 --> 00:01:50.840
但我们还在循环里

00:01:50.840 --> 00:01:57.030
于是我们回到这上面来 给 i 增量 使其变为 6 而 6 仍小于或等于 10

00:01:57.030 --> 00:02:00.460
于是再进入这里 再检查 Wi-Fi

00:02:00.459 --> 00:02:02.259
如果我们还在网络范围内

00:02:02.260 --> 00:02:06.850
这个函数还是会返回真值 因而 Wifi found 这条信息会再次输出

00:02:06.849 --> 00:02:09.489
事实上 这里的 for 循环在剩下的迭代中

00:02:09.490 --> 00:02:12.900
还会不断地输出 Wifi 提示

00:02:12.900 --> 00:02:15.939
这并不完全符合我们的设想

00:02:15.939 --> 00:02:20.710
我想象的是 一旦我们找到一个 Wi-Fi 网络

00:02:20.710 --> 00:02:23.409
就结束这次查找

00:02:23.409 --> 00:02:27.009
好在 Java 提供了关键字 break

00:02:27.009 --> 00:02:29.620
我们只需把关键字 break 加到这里

00:02:29.620 --> 00:02:35.289
这样一旦找到了一个 Wi-Fi 并输出了信息 Wifi found

00:02:35.289 --> 00:02:39.275
break 就会彻底跳出这个 for 循环

00:02:39.275 --> 00:02:44.474
所以无论条件是真还是假 循环都不会继续了

00:02:44.474 --> 00:02:48.180
有了这个 我们将来遇到的很多情况都能迎刃而解了

00:02:48.180 --> 00:02:50.810
事实上 break 也适用于 while 循环

00:02:50.810 --> 00:02:53.175
我们来看一个案例

00:02:53.175 --> 00:02:55.480
想象你在玩一个游戏

00:02:55.479 --> 00:02:59.349
你得把一个骰子掷出六点

00:02:59.349 --> 00:03:03.114
但如果掷出的是三点 你就输了

00:03:03.115 --> 00:03:08.740
所以我们要实现这么个函数 一直掷骰子直到掷出六点

00:03:08.740 --> 00:03:10.430
如果掷出六点 你就赢了

00:03:10.430 --> 00:03:12.900
但如果掷出三点 你就输了

00:03:12.900 --> 00:03:19.034
函数将返回一个布尔值 如果我赢了的话 值为真 如果没有赢 值为假

00:03:19.034 --> 00:03:21.004
我们就管它叫 rollASix 吧

00:03:21.004 --> 00:03:22.944
该函数不接受任何参数

00:03:22.944 --> 00:03:26.919
在里面 我们只需用 rollDice 函数来掷骰子

00:03:26.919 --> 00:03:31.209
并将结果赋值给整数变量 dice

00:03:31.210 --> 00:03:33.020
然后用 while 循环来执行这个过程

00:03:33.020 --> 00:03:36.359
当 dice 不等于 6 时 继续掷骰子

00:03:36.359 --> 00:03:42.455
完美 这个 while 循环会一直掷骰子 直到掷出六点

00:03:42.455 --> 00:03:46.935
不过 我们需要判断骰子掷出的是不是三点

00:03:46.935 --> 00:03:48.414
所以我们加上这个 if 条件

00:03:48.414 --> 00:03:52.424
如果 dice 等于 3 我们就 break

00:03:52.425 --> 00:03:56.050
这里 break 的意思就是 我们要跳出这个 while 循环

00:03:56.050 --> 00:03:57.915
不会再掷骰子了

00:03:57.914 --> 00:04:00.370
不会再执行 while 循环里的语句了

00:04:00.370 --> 00:04:02.504
循环彻底结束了 我们输了

00:04:02.504 --> 00:04:03.819
不过 不知你是否注意到了

00:04:03.819 --> 00:04:08.275
无论我们掷出了六点还是三点

00:04:08.275 --> 00:04:10.930
都只会到达这里

00:04:10.930 --> 00:04:13.180
函数停止后 我们无法得知

00:04:13.180 --> 00:04:16.155
自己掷出的是六点还是三点

00:04:16.154 --> 00:04:20.389
所以要知道赢了还是没赢

00:04:20.389 --> 00:04:23.675
我们需要在这再加一个 if 条件

00:04:23.675 --> 00:04:25.780
如果 dice 等于 6

00:04:25.779 --> 00:04:27.279
我们就返回真值

00:04:27.279 --> 00:04:30.304
否则就返回假值

00:04:30.305 --> 00:04:33.894
这样一来 待 while 循环不断掷骰子

00:04:33.894 --> 00:04:38.074
掷出了六点后 我们就会到达这个阶段

00:04:38.074 --> 00:04:42.490
检查 dice 是否真的为 6 然后返回真值

00:04:42.490 --> 00:04:46.990
如果重掷期间 dice 刚好变成 3

00:04:46.990 --> 00:04:48.910
那我们就会跳出循环到这里

00:04:48.910 --> 00:04:52.295
进行 if 条件判断 因为不等于 6

00:04:52.295 --> 00:04:55.520
所以就是其它情况 因此返回出假值

00:04:55.519 --> 00:05:00.354
完美 综上我们可以看出 就算是用于 while 循环 break 也很方便

00:05:00.355 --> 00:05:03.270
现在 我们来看一个案例

00:05:03.269 --> 00:05:07.000
你得用关键字 break 来解决一个问题

