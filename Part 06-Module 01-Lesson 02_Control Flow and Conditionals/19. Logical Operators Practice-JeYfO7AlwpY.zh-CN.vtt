WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.480
到目前为止 我们一直在配合表达式使用逻辑运算符

00:00:03.480 --> 00:00:05.280
例如是否 3 小于 5？

00:00:05.280 --> 00:00:07.165
或者是否 6 大于 1？

00:00:07.165 --> 00:00:09.644
除了逻辑运算符

00:00:09.644 --> 00:00:11.867
我们还得记录所有这些不等式

00:00:11.868 --> 00:00:15.449
逻辑运算符的另一种用法是

00:00:15.449 --> 00:00:19.554
直接组合 true 或 false 这两个值

00:00:19.554 --> 00:00:22.274
现在我们不检查是否 6 大于 1

00:00:22.274 --> 00:00:25.704
因为它的值为真 所以我直接在这里写下值 true

00:00:25.704 --> 00:00:30.529
我们可能遇到的所有其他对比都能简化为 true 或 false

00:00:30.530 --> 00:00:33.689
我可以将这些值与逻辑运算符组合

00:00:33.689 --> 00:00:35.265
我们以 NOT 运算符为例

00:00:35.265 --> 00:00:37.994
它的表达符号是感叹号

00:00:37.994 --> 00:00:43.875
代码 !6&gt;1 等同于代码 !true

00:00:43.875 --> 00:00:49.019
因为表达式 6&gt;1 的布尔值为真

00:00:49.020 --> 00:00:52.740
所以这两个表达式的值都为假

00:00:52.740 --> 00:00:56.969
因为 NOT 运算符会将其运算的任何布尔值转换为相反值

00:00:56.969 --> 00:00:58.814
非真即为假

00:00:58.814 --> 00:01:01.344
非假即为真

00:01:01.344 --> 00:01:03.494
现在我们来看看 AND 运算符

00:01:03.494 --> 00:01:05.512
对于 AND 运算符

00:01:05.513 --> 00:01:08.400
真 AND 真等于真

00:01:08.400 --> 00:01:11.800
但假 AND 真等于假

00:01:11.799 --> 00:01:14.429
这是因为 AND 运算符要求两个组合条件都为真时

00:01:14.430 --> 00:01:18.680
整个表达式的值才为真

00:01:18.680 --> 00:01:22.605
如果组合条件中有一个或者两个都为假

00:01:22.605 --> 00:01:26.174
则整个 AND 组合的值便为假

00:01:26.174 --> 00:01:27.719
将 AND 这种运算符应用到实际生活场景中讨论

00:01:27.719 --> 00:01:31.804
可能有助于大家理解

00:01:31.805 --> 00:01:33.945
我们以天气为例

00:01:33.944 --> 00:01:36.764
假设晴天下雨

00:01:36.765 --> 00:01:38.799
就会出现彩虹

00:01:38.799 --> 00:01:43.679
那么如果天晴这个条件为真 下雨这个条件也为真才会出现彩虹

00:01:43.680 --> 00:01:46.095
但如果只有一个条件为真

00:01:46.094 --> 00:01:47.530
比方说只是天晴

00:01:47.530 --> 00:01:49.799
那么就不会出现彩虹

00:01:49.799 --> 00:01:51.879
如果只是下雨也是如此

00:01:51.879 --> 00:01:53.609
如果两个条件都不满足

00:01:53.609 --> 00:01:55.929
那么也不会出现彩虹

00:01:55.930 --> 00:02:01.670
要想出现彩虹 天晴和下雨这两个条件必须同时满足

00:02:01.670 --> 00:02:05.204
AND 运算符就是这样来判定真值的

00:02:05.204 --> 00:02:09.030
对于组合了两个测试条件的 AND 表达式

00:02:09.030 --> 00:02:12.810
两个条件必须都为真 整个表达式的值才为真

00:02:12.810 --> 00:02:14.235
在所有其他情况下

00:02:14.235 --> 00:02:16.390
整个表达式的值将为假

00:02:16.389 --> 00:02:18.934
OR 运算符则不同

00:02:18.935 --> 00:02:20.759
OR 运算符只要求两个组合条件之一得到满足

00:02:20.759 --> 00:02:24.269
整个表达式的值便为真

00:02:24.270 --> 00:02:27.335
所以真 OR 真的值为真

00:02:27.335 --> 00:02:29.760
假 OR 真的值也为真

00:02:29.759 --> 00:02:34.364
因为在这两种情况中 都有至少一个组合条件的值为真

00:02:34.365 --> 00:02:39.270
仅当两个组合条件都为假时 整个表达式的值才为假

00:02:39.270 --> 00:02:41.973
为了更好地理解 OR 运算符

00:02:41.973 --> 00:02:45.030
我们想象一下开机使用笔记本电脑的情况

00:02:45.030 --> 00:02:46.500
要让笔记本电脑运行起来

00:02:46.500 --> 00:02:51.675
我们需要通过电池或外部电源为它供电

00:02:51.675 --> 00:02:53.650
如果这两个条件都满足

00:02:53.650 --> 00:02:56.879
假设笔记本电脑既拥有充好电的电池 又连接至外部电源

00:02:56.879 --> 00:02:58.560
那么它应该能正常运行

00:02:58.560 --> 00:03:02.129
如果只有其中一个条件得到满足 它也能正常运行

00:03:02.129 --> 00:03:04.724
比如它可以仅使用充好电的电池工作

00:03:04.724 --> 00:03:07.019
也可以在仅连接外部电源时正常运行

00:03:07.020 --> 00:03:10.290
就算电池没有充好电

00:03:10.289 --> 00:03:12.840
只有当两个条件都不满足时

00:03:12.840 --> 00:03:15.750
笔记本电脑才会因得不到电源而无法运行

00:03:15.750 --> 00:03:19.370
也就是它既没有充满电的电池 也没有连接外部电源

00:03:19.370 --> 00:03:21.960
OR 运算符的运算原理也是如此

00:03:21.960 --> 00:03:25.805
就像笔记本电脑可通过电池或外部电源供电一样

00:03:25.805 --> 00:03:28.409
当组合的一个或两个条件都为真时

00:03:28.409 --> 00:03:31.219
整个 OR 表达式的值便为真

00:03:31.219 --> 00:03:34.979
仅当两个测试条件都为假时 整个表达式的值才为假

00:03:34.979 --> 00:03:37.364
现在我们已经明白 AND 和 OR 的运算原理

00:03:37.365 --> 00:03:40.080
但如果将它们组合到较长的测试表达式中 又会怎样？

00:03:40.080 --> 00:03:44.445
这个较长的表达式中包含一个 AND 运算符和一个 OR 运算符

00:03:44.444 --> 00:03:46.125
这个代码可以读为

00:03:46.125 --> 00:03:48.520
假 AND 真 OR 真

00:03:48.520 --> 00:03:50.745
你认为它的值是什么？

00:03:50.745 --> 00:03:55.379
在这种情况下 Java 将首先检查通过 AND 组合的条件

00:03:55.379 --> 00:03:58.984
然后再检查通过 OR 组合的条件

00:03:58.985 --> 00:04:02.010
逻辑运算符的运算顺序就是这样的

00:04:02.009 --> 00:04:04.560
所以它会先检查 假 AND 真 这个组合

00:04:04.560 --> 00:04:07.500
得到这个组合的值为假

00:04:07.500 --> 00:04:10.500
因为 AND 运算符要求两个组合条件都为真

00:04:10.500 --> 00:04:14.020
整个组合的值才为真

00:04:14.020 --> 00:04:17.250
所以这个表达式的值为假

00:04:17.250 --> 00:04:23.310
剩下的部分就相当于第一个表达式的简化版 假 OR 真

00:04:23.310 --> 00:04:25.439
我们知道 OR 运算符只要求组合条件之一为真

00:04:25.439 --> 00:04:28.459
整个组合的值便为真

00:04:28.459 --> 00:04:31.004
所以这整个表达式的值为真

00:04:31.004 --> 00:04:32.629
请记得这两个表达式是等效的

00:04:32.629 --> 00:04:36.089
所以这个较大的表达式的值也为真

00:04:36.089 --> 00:04:39.449
但如果我们想要首先检查 OR 组合呢？

00:04:39.449 --> 00:04:41.189
也就是 真 OR 真 这部分

00:04:41.189 --> 00:04:45.704
要推翻标准运算顺序 先检查这个 OR 组合

00:04:45.704 --> 00:04:48.904
我们可以为这部分表达式加一对括号

00:04:48.904 --> 00:04:53.409
Java 将始终先于任何其他部分执行括号中的代码

00:04:53.410 --> 00:04:58.120
所以这个 带括号 OR 部分的检查表达式的读取方式将有所不同

00:04:58.120 --> 00:05:02.944
在这种情况下 Java 将首先检查括号中的代码 真 OR 真

00:05:02.944 --> 00:05:05.524
由于这两个条件至少有一个为真

00:05:05.524 --> 00:05:06.879
实际上两个条件都为真

00:05:06.879 --> 00:05:09.569
所以这个 OR 组合的值为真

00:05:09.569 --> 00:05:13.250
现在这些条件便简化为一个 假 AND 真 组合

00:05:13.250 --> 00:05:16.915
因为这些条件中有一个为假 而且是通过 AND 运算符组合

00:05:16.915 --> 00:05:19.835
所以这整个表达式的值为假

00:05:19.834 --> 00:05:22.509
虽然这两个表达式看上去非常相似

00:05:22.509 --> 00:05:25.230
运算顺序却导致其结果不同

00:05:25.230 --> 00:05:29.285
只有当我们通过实践 熟练运用逻辑运算符 它们才能发挥出最大作用

00:05:29.285 --> 00:05:32.170
让我们在接下来的测验中 学习更多类似组合

